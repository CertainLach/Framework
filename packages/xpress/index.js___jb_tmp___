"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uws_1 = require("uws");
const logger_1 = require("@meteor-it/logger");
const utils_1 = require("@meteor-it/utils");
const router_1 = require("@meteor-it/router");
const http2_1 = require("http2");
const http_1 = require("http");
const url_1 = require("url");
const path_1 = require("path");
const fs_1 = require("fs");
const { HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_LAST_MODIFIED, HTTP2_HEADER_CACHE_CONTROL, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_CONTENT_DISPOSITION, HTTP2_HEADER_UPGRADE, HTTP2_HEADER_ACCEPT_ENCODING } = http2_1.constants;
let xpressLogger = new logger_1.default('xpress');
class XpressRouterStream {
    constructor(reqHeaders, resHeaders) {
        this.hasDataSent = false;
        this.reqHeaders = reqHeaders;
        this.resHeaders = resHeaders;
    }
    status(status) {
        if (status > 999 || status < 100)
            throw new Error('incorrect status passed');
        this.resHeaders[HTTP2_HEADER_STATUS] = status;
        return this;
    }
    /**
     * Sends data
     * @param text
     */
    send(text) {
        this.hasDataSent = true;
        this.respond();
        if (this.isHttp2) {
            this.res.stream.write(text);
            this.res.stream.end();
        }
        else {
            this.res.write(text);
            this.res.end();
        }
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Pipes stream to real stream
     * @param stream
     */
    sendStream(stream) {
        this.hasDataSent = true;
        if (this.isHttp2) {
            this.respond();
            stream.pipe(this.res.stream);
        }
        else {
            this.respond();
            stream.pipe(this.res);
        }
    }
    /**
     * Just sends file, without any header modifications
     * Complex sends should be handled by users
     * @param path
     */
    sendFile(path) {
        this.hasDataSent = true;
        if (this.isHttp2) {
            this.res.stream.respondWithFile(path, this.resHeaders, {});
        }
        else {
            this.respond();
            fs_1.createReadStream(path).pipe(this.res);
        }
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * After this call, developer should handle everything yourself
     */
    respond() {
        this.hasDataSent = true;
        if (this.isHttp2) {
            this.res.stream.respond(this.resHeaders);
        }
        else {
            const newHeaders = {};
            for (let key in this.resHeaders) {
                if (key !== HTTP2_HEADER_STATUS)
                    newHeaders[key] = this.resHeaders[key];
            }
            this.res.writeHead(this.resHeaders[HTTP2_HEADER_STATUS] || 200, newHeaders);
        }
    }
    acceptsEncoding(encoding) {
        return (this.reqHeaders[HTTP2_HEADER_ACCEPT_ENCODING] || '').split(',').map(e=>e.trim()).includes(encoding);
    }
    /**
     * Define multiplex point
     * @param path
     */
    pushStream(path) {
        return new Promise((res, rej) => {
            if (!this.canPushStream)
                return rej(new Error("pushStream isn't supported for this session"));
            // @types/node sucks for http2
            this.res.stream.pushStream({ ...this.resHeaders, [HTTP2_HEADER_PATH]: path }, (err, stream, resHeaders) => {
                if (err)
                    return rej(err);
                const wrap = new XpressRouterStream(this.reqHeaders, {});
                wrap.res = { ...this.res, stream };
                res(wrap);
            });
        });
    }
    ;
    get canPushStream() {
        return this.hasStream && this.res.stream.pushAllowed;
    }
    get isHttp2() {
        return this.hasStream;
    }
    get hasStream() {
        return !!(this.res && this.res.stream);
    }
    get hasSocket() {
        return !!this.socket;
    }
}
/**
 * Throw this error if you want to customize XPress error message
 * (By default, all thrown errors are displayed as 500 Internal Server Error)
 */
class HttpError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
    }
}
// noinspection JSUnusedGlobalSymbols
/**
 * Routing helper to pass default XPress context
 * Read docs of Router
 */
class Router extends router_1.default {
    constructor(defaultState = null) {
        super(defaultState);
    }
}
exports.Router = Router;
// noinspection RegExpRedundantEscape
const PATH_SEP_REGEXP = new RegExp(`\\${path_1.sep}`, 'g');
// Default config
const WS_SERVER_CONFIG = {
    perMessageDeflate: {
        zlibDeflateOptions: {
            chunkSize: 1024,
            memLevel: 7,
            level: 3,
        },
        zlibInflateOptions: {
            chunkSize: 10 * 1024
        },
        // Other options settable:
        clientNoContextTakeover: true,
        serverNoContextTakeover: true,
        clientMaxWindowBits: 10,
        serverMaxWindowBits: 10,
        // Below options specified as default values.
        concurrencyLimit: 10,
        threshold: 1024,
    }
};
/**
 * XPress web server API
 */
class XPress extends router_1.default {
    constructor(name, defaultState = null) {
        super(defaultState);
        if (name instanceof logger_1.default)
            this.logger = name;
        else
            this.logger = new logger_1.default(name);
    }
    // noinspection JSMethodCanBeStatic
    async requestHandler(req, res) {
        // console.log('HTTP/1 Request');
        const url = req.url;
        let { pathname, query } = url_1.parse(url, true);
        if (pathname === undefined) {
            res.stream.destroy();
            return;
        }
        pathname = path_1.normalize(pathname).replace(PATH_SEP_REGEXP, '/');
        const method = req.method;
        const wrappedMainStream = new XpressRouterStream(req.headers, {});
        wrappedMainStream.req = req;
        wrappedMainStream.res = res;
        try {
            await this.route(pathname, ctx => {
                ctx.query = query;
                ctx.method = method;
                ctx.stream = wrappedMainStream;
            });
            if (!wrappedMainStream.hasDataSent && !wrappedMainStream.res.headersSent) {
                wrappedMainStream.resHeaders = {};
                wrappedMainStream.status(404).send(developerErrorPageHandler('404: Page Not Found', `Page not found at ${pathname}`, process.env.NODE_ENV === 'production' ? undefined : new Error('Reference stack').stack));
            }
        }
        catch (e) {
            this.logger.error(e.stack);
            wrappedMainStream.resHeaders = {};
            wrappedMainStream.status(500).send(developerErrorPageHandler('500: Internal Server Error', e.message, process.env.NODE_ENV === 'production' ? undefined : e.stack));
        }
    }
    /**
     * HTTP/2
     * (Fuck you, browsers, for not supporting HTTP/2 over TCP!)
     * @param stream
     * @param headers
     * @param flags
     */
    /*private async streamHandler(stream: ServerHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) {
        const url = headers[HTTP2_HEADER_PATH] as string;
        let {pathname, query} = parse(url, true);
        if (pathname === undefined) {
            stream.end();
            return;
        }
        pathname = normalize(pathname).replace(PATH_SEP_REGEXP,'/');
        const method = headers[HTTP2_HEADER_METHOD] as any;
        const wrappedMainStream = new XpressRouterStream(headers, {});
        wrappedMainStream.stream=stream;
        try {
            await this.route(pathname, ctx => {
                ctx.query = query as { [key: string]: string };
                ctx.method = method;
                ctx.stream = wrappedMainStream;
            });
            if (!wrappedMainStream.hasDataSent) {
                wrappedMainStream.resHeaders = {};
                wrappedMainStream.status(404).send(developerErrorPageHandler('404: Page Not Found',`Page not found at ${pathname}`,process.env.NODE_ENV==='production'?undefined:new Error('Reference stack').stack));
            }
        }catch(e){
            wrappedMainStream.resHeaders = {};
            wrappedMainStream.status(500).send(developerErrorPageHandler('500: Internal Server Error',e.message,process.env.NODE_ENV==='production'?undefined:e.stack));
        }
    }*/
    /**
     * HTTP/1
     * @param request
     * @param socket
     * @param head
     */
    async upgradeHandler(request, socket, head) {
        const headers = request.headers;
        const url = request.url;
        if (url === undefined) {
            socket.destroy();
            return;
        }
        let { pathname, query } = url_1.parse(url, true);
        if (pathname === undefined) {
            socket.destroy();
            return;
        }
        pathname = path_1.normalize(pathname).replace(PATH_SEP_REGEXP, '/');
        const method = request.method;
        const upgradeType = headers[HTTP2_HEADER_UPGRADE];
        if (upgradeType === 'websocket' && method === 'GET') {
            this.wsServer.handleUpgrade(request, socket, head, async (ws) => {
                const wrapperMainStream = new XpressRouterStream(headers, {});
                wrapperMainStream.socket = ws;
                await this.route(pathname, ctx => {
                    ctx.query = query;
                    ctx.method = method;
                    ctx.stream = wrapperMainStream;
                });
                // Dirty check for handled websocket
                // Will break on UWS update
                // https://github.com/discordjs/uws/blob/master/src/uws.js#L90
                if (wrapperMainStream.socket.internalOnMessage === wrapperMainStream.socket.internalOnClose) {
                    // 1005 - CLOSED_NO_STATUS
                    wrapperMainStream.socket.close(1005);
                }
            });
        }
        else {
            // IDK how to handle
            socket.destroy();
        }
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * bind()
     * @param host host to bind on
     * @param port port to bind on
     */
    listenHttp(host = '0.0.0.0', port) {
        this.ensureWebSocketReady();
        let server = http_1.createServer(this.requestHandler.bind(this));
        // There is no ALPN negotigation for HTTP/1 over TLS D:
        // And, since HTTP/2 over tcp isn't supported in browsers,
        // Http server is only for HTTP/1.
        // TODO: Add option for listening HTTP/2 over TCP for reverse-proxy purposes
        // server.on('stream', this.streamHandler.bind(this));
        server.on('upgrade', this.upgradeHandler.bind(this));
        return new Promise((res, rej) => {
            server.listen(port, host, () => {
                this.logger.debug('Listening (http) on %s:%d...', host, port);
                res();
            });
        });
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * bind()
     * @param host host to bind on
     * @param port port to bind on
     * @param options settings
     */
    listenHttps(host = '0.0.0.0', port, { key, cert }) {
        this.ensureWebSocketReady();
        let server = http2_1.createSecureServer({
            key, cert,
            allowHTTP1: true
        }, this.requestHandler.bind(this));
        // server.on('stream', this.streamHandler.bind(this));
        server.on('upgrade', this.upgradeHandler.bind(this));
        return new Promise((res, rej) => {
            server.listen(port, host, () => {
                this.logger.debug('Listening (https) on %s:%d...', host, port);
                res();
            });
        });
    }
    ensureWebSocketReady() {
        if (this.wsServer)
            return;
        this.wsServer = new uws_1.Server({ noServer: true });
    }
}
exports.default = XPress;
/**
 * Fancify error message for developer
 * @param title
 * @param desc
 * @param stack
 */
function developerErrorPageHandler(title, desc, stack = undefined) {
    // Developer friendly
    if (title)
        title = utils_1.encodeHtmlSpecials(title).replace(/\n/g, '<br>');
    if (desc)
        desc = utils_1.encodeHtmlSpecials(desc).replace(/\n/g, '<br>');
    if (stack)
        stack = utils_1.encodeHtmlSpecials(stack).replace(/\n/g, '<br>');
    return `<!DOCTYPE html><html><head><title>${title}</title></head><body><h1>${desc}</h1><hr>${stack ? `<code style="white-space:pre;">${stack}</code>` : ''}<hr><h2>uFramework xPress</h2></body></html>`;
}
exports.developerErrorPageHandler = developerErrorPageHandler;
// noinspection JSUnusedGlobalSymbols
/**
 * Fancify error message for user
 * @param hello
 * @param whatHappened
 * @param sorry
 * @param post
 */
function userErrorPageHandler(hello, whatHappened, sorry, post) {
    // User friendly
    if (hello)
        hello = utils_1.encodeHtmlSpecials(hello.replace(/\n/g, '<br>'));
    if (whatHappened)
        whatHappened = utils_1.encodeHtmlSpecials(whatHappened.replace(/\n/g, '<br>'));
    if (sorry)
        sorry = utils_1.encodeHtmlSpecials(sorry.replace(/\n/g, '<br>'));
    if (post)
        post = utils_1.encodeHtmlSpecials(post.replace(/\n/g, '<br>'));
    return `<html><body style='font-family:Arial,sans-serif;font-size:22px;color:#CCC;background:#222;padding:40px;'>${hello}<br/><br/><span style='color:#FC0;font-weight:600;'>${whatHappened}</span><br/><br/>${sorry}<br/><br/><span style='font-size: 14px;'>${post}</span></body></html>`;
}
exports.userErrorPageHandler = userErrorPageHandler;
//# sourceMappingURL=index.js.map